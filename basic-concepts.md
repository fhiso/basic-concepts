---
title: Basic Concepts for Genealogical Standards
date: 10 October 2019
numbersections: true
...
# Basic Concepts for Genealogical Standards

{.ednote ...} This is a **working draft** of a standard covering 
basic concepts that are expected to be used in multiple standards.
This document is not endorsed by the FHISO membership, and may be
updated, replaced or obsoleted by other documents at any time.

The public [tsc-public@fhiso.org](https://tech.fhiso.org/tsc-public)
mailing list is the preferred place for comments, discussion and other
feedback on this draft.

--------------           ---------------------------------------------
Latest public version:   `https://fhiso.org/TR/basic-concepts`
This version:            *URL to be determined*
Previous version:        `https://fhiso.org/TR/basic-concepts-20180316`
--------------           ---------------------------------------------
{/}

FHISO's **Basic Concepts for Genealogical Standards** standard defines
various low-level concepts that are used in many genealogical standards,
and whose definitions do not logically belong in any one particular
higher-level standard.  Having a single definition of these concepts
eliminates the possibility of incompatibilities between standards
arising due to small differences in these basic concepts.

*String* are used in practically all standards, and a standard
definition is given in {§strings} of this standard, together with
various related concepts such as *characters* and *whitespace*.  The use
of *language tags* is defined briefly in {§lang-tags}.
*Terms* are defined in {§terms} as a form of extensible identifier using
IRIs, and {§iri-resn} discusses information that may be retrieved from
these IRIs.

## Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *may* issue a warning or error message, and *may*
terminate processing of the document or data fragment.

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of
&#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is
attached to the capitalisation of grammar symbols.  *Conforming*
applications *must not* generate data not conforming to the syntax given
here, but non-conforming syntax *may* be accepted and processed by a
*conforming* application in an implementation-defined manner.

This standard uses *prefix notation*, as defined in {§prefix-notn} of
this standard, when discussing specific *terms*.  The following *prefix*
bindings are assumed in this standard:

------           -----------------------------------------------
`rdf`            `http://www.w3.org/1999/02/22-rdf-syntax-ns#`
`rdfs`           `http://www.w3.org/2000/01/rdf-schema#`
`xsd`            `http://www.w3.org/2001/XMLSchema#`
`types`          `https://terms.fhiso.org/types/`
------           -----------------------------------------------

{.note}  The particular *prefix* assigned above have no relevance
outside this standard document as *prefix notation* is not used in the
formal data model defined by this standard.  This notation is simply a
notational convenience to make the standard easier to read.

## Characters and strings                                     {#strings}

{.ednote}  This section has been changed in this draft to define *line
breaks* and to allow *line break normalisation* on any *string*.  The
discussion on *private use characters* is also new.

**Characters** are atomic units of text which are specified by reference to
their **code point** number in [Unicode], without regard to any particular
character encoding.  

{.note} The character encoding is a property of the serialisation, and
not defined in this standard.  Non-Unicode encodings are not precluded,
so long as it is defined how characters in that encoding corresponds to
Unicode characters.

{.ednote} The first draft of this standard defined *characters* by
reference to the ISO 10646 standard.  This draft references the Unicode
standard instead.  The two are standards are developed in parallel and
kept in synch, but the Unicode standard is considerably more detailed.
Even though the ISO standard is available for free, the Unicode standard
is much more widely known.
 
*Characters* may be identified in this standard by their hexadecimal
*code point* prefixed with "U+".

{.example}  The exclamation mark "`!`" is *code point* 33 in Unicode,
or 21 in hexadecimal.  In this standard it written U+0021.

*Characters* *must* match the `Char` production from
&#x5B;[XML](https://www.w3.org/TR/xml11/)].

    Char  ::=  [#1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

{.note} This includes all *code points* except the null character,
surrogates (which are reserved for encodings such as UTF-16 and not
characters in their own right), and the invalid characters U+FFFE and
U+FFFF.

A **string** is a sequence of zero or more *characters* which is used to
encode textual data.  It matches the following `String` production:

    String  ::=  Char*

{.note ...} This definition of a *string* is identical to the definition
of the `string` datatype defined in 
&#x5B;[XSD Pt2](https://www.w3.org/TR/xmlschema11-2/)], used in many XML
and Semantic Web technologies.

This definition of a *string* differs very slightly from JSON's
definition of a string, as defined in 
&#x5B;[RFC 7159](https://tools.ietf.org/html/rfc7159)], as a JSON string
may include the null *character* (U+0000).  This is the only difference
between a JSON string and FHISO's definition of a *string*.  As a
*string* *should not* be used to contain raw binary data, this
difference is not anticipated to cause a problem.  If an application
needs to store binary data in *string*, it *should* encode it in a
textual form, for example with the Base64 data encoding scheme defined in 
&#x5B;[RFC 4648](https://tools.ietf.org/html/rfc4648)].
{/}

Applications *may* convert any *string* into Unicode Normalization Form
C, as defined in any version of Unicode Standard Annex #15 &#x5B;[UAX
15](http://unicode.org/reports/tr15/)].

{.note} Normalization Form C and Normalization Form D allow easier
searching, sorting and comparison of *strings* by picking a canonical
representation of accented characters.  The conversion between
Normalization Forms C and D is lossless and therefore reversible, but
the initial conversion to either form is not reversible.  This allows a 
*conformant* application to normalise *strings* internally and not
retain the unnormalised form; however, an application doing so *must*
ensure the *string* is in Normalization Form C upon export, this being
the more usual form for use in documents.

Applications *may* apply *line break normalisation*, as defined in
{§whitespace}, to any *string*.  Data which relies on the differences
between the various types of *line break* *must not* be represented in
a *string*.

{.note}  This standard defines a *string* as a way of encoding "textual
data" without defining precisely what this means.  Data which relies on
the difference between types of *line break* is not considered text for
the purposes of the `text/*` family of MIME types, as described in
§4.1.1 of [RFC 2046].  It is suggested that the phrase "textual data" in
the definition of a string be interpreted similarly.

*Conformant* applications *must* be able to store and process *strings*
containing arbitrary *characters*, except *restricted characters* as
defined in {§restricted-chars}.  In particular, applications *must*
be able to handle *characters* which correspond to unassigned Unicode
*code points* as they may be assigned in future versions of [Unicode].
Applications *must* also be able to process *characters* outside
Unicode's Basic Multilingual Plane – that is, *characters* with a
*code point* of U+10000 or higher.

{.note} This means applications *must not* represent *strings*
internally in the UCS-2 encoding which does not accommodate *characters*
outside the Basic Multilingual Plane.  The UTF-16 encoding form defined
in §2.5 and §2.6 of [Unicode] provides a 16-bit encoding that is
backwards compatible with UCS-2 but allows arbitrary *characters* to be
represented through the use of Unicode surrogate pairs.

### Whitespace and line breaks                             {#whitespace}

**Whitespace** is defined as a sequence of one or more space
*characters*, carriage returns, line feeds, or tabs.  It matches the
production `S` from &#x5B;[XML](https://www.w3.org/TR/xml11/)].

    S  ::=  (#x20 | #x9 | #xD | #xA)+

{.note}  This definition only includes common ASCII whitespace
*characters* and does not include every Unicode *character* that
could be considered to be whitespace.  In particular, the vertical tab
(U+000B), form feed (U+000C), next line *character* (U+0085) and
no-break space (U+00A0) are all explicitly excluded.

**Whitespace normalisation** is the process of discarding any leading
or trailing *whitespace* from a *string*, and replacing all other
*whitespace* in a *string* with a single space (U+0020) *character*.  

{.note}  The definition of *whitespace normalisation* is identical to
that in &#x5B;[XML](https://www.w3.org/TR/xml11/)].

In the event of a difference between the definitions of the `Char`,
`RestrictedChar` and `S` productions given here and those in
&#x5B;[XML](https://www.w3.org/TR/xml11/)], the definitions in the
latest edition of XML 1.1 specification are definitive.

A **line break** is defined as a line feed (U+000A), or carriage return
(U+000D) followed by an *optional* line feed (U+000A).  It matches the
following `LB` production:

    LB  ::=  #xD #xA? | #xA

{.note}  This definition of a *line break* matches the form of line
endings used on Unix, Linux and modern Mac OS (U+000A), the
traditional Mac OS form (U+000D), and Windows line endings (U+000D
U+000A).  [UAX 14] also lists vertical tab (U+000B), form feed
(U+000C), next line (U+0085), line separator (U+2028) and paragraph
separator (U+2029) as forms of *line breaks*.  This standard does not
include these in the `LB` production as they have specific meanings in
addition to being *line breaks*.

**Line break normalisation** is the process of replacing every *line
break* in a *string*, regardless of its form, with the same
implementation-defined form of *line break*.

{.note}  It is anticipated but not required that applications will opt
to normalise *line breaks* to the applicable native *line break*, for
example U+000A in a Linux application.

### Tagged strings                                     {#tagged-strings}

A **tagged string** is a *string* which is accompanied by one or more
supplementary *strings* called **tags** that provide further information
to aid the interpretation of the *tagged string*.  

{.note}  The *tags* are not part of the *tagged string* but are stored
alongside it.  Thus the value of a *tagged string* is just the value of
main string, without any associated *tags*.

{.note}  This can considered a lightweight mechanism for recording
specific pieces of metadata about the *tagged string*.  It is not
intended as a framework for associating arbitrary metadata with a
*string*.

This standard defines two specific types of *tagged strings*.
*Language-tagged strings*, which are defined {§lang-tagged-strings},
have a single *tag* which is a *language tag*.  *Literals*, defined in
{§literals}, extend this concept by adding a second *tag* which is a
*datatype name*.

### Restricted characters                            {#restricted-chars}

*Characters* matching the `RestrictedChar` production from
&#x5B;[XML](https://www.w3.org/TR/xml11/)] are called **restricted
characters**.  They *should not* appear in *strings*, and applications
*may* process such characters in an implementation-defined manner or
reject *strings* containing them.

    RestrictedChar  ::=  [#x1-#x8] | [#xB-#xC] | [#xE-#x1F]
                           | [#x7F-#x84] | [#x86-#x9F]

{.note} This includes all C0 and C1 control characters except tab
(U+0009), line feed (U+000A), carriage return (U+000D) and next line
(U+0085).

{.example} As *conformant* applications can process C1 control
characters in an implementation-defined manner, they can opt to handle
Windows-1252 quotation marks in data masquerading as Unicode.
Applications *must not* treat non-ASCII characters (other than C1
control characters) as ANSEL, the character set properly used in [GEDCOM],
as [ANSEL]'s non-ASCII characters do not correspond to `RestrictedChar`s.

{.note} The ability to reject *strings* containing *restricted
characters* is interpreted quite broadly.  An application *may* treat
the *string* as an error and refuse to parse the dataset containing it,
or *may* drop the *string* from the dataset with or without a warning.

### Private use characters                                  {#pua-chars}

*Characters* from the Private Use Areas defined in §23.5 of [Unicode]
are called **private use characters** and match the following
production:

    PrivateUseChar  ::=   [#xE000-#xF8FF] | [#F0000-#xFFFFD] 
                            | [#100000-#x10FFFD]

*Private use characters* *may* be used *tagged strings* if one of
the *tags* defines how *private use chracters* are defined, and
applications *must* be able to store and process such *strings*.

{.example}  A future standard might define an `x-mufi` private use
language subtag (per §2.2.7 of [RFC 5646]), which is used to mean that
*private use characters* are to be interpreted according to [MUFI], a
standard for encoding many obscure mediæval characters, ligatures and
scribal abbreviations that are not current in Unicode.  A *string* with
a *language tag* like `non-x-mufi` would then be interpreted as saying
the *string* was in Old Norse and used [MUFI] *private use characters*.  

Any *private use characters* that are encountered outside a *tagged
string*, or in a *tagged string* in which all of the *tags* are known
to not define the use of *private use characters*, *shall* be considered
*restricted characters*.  *Private use characters* in *tagged strings*
where any *tag* is unknown to the application *must not* be considered
*restricted characters*.

{.example}  A *language-tagged string* with *language tag* `pt-BR`
(meaning Brazilian Portuguese) uses only well-known *language tag*
components that do not define how *private use characters* are used.  If
*private use characters* are found in such a *string*, the *string*
*may* be treated as an error or handled in an implementation-defined
manner.

{.note} Neither the `und` *language tag* nor the `rdf:langString`
*datatype*, which are the default *tags* for *language-tagged strings*
and *literals* as defined in {§lang-tagged-strings} and {§literals},
define the use of *private use characters*, so explicit *tags* *must* be
provided if *private use characters* are to be interpreted reliably.

## Language tags                                            {#lang-tags}

A **language tag** is a *string* that is used to represent a human
language, and where appropriate the script and regional variant or
dialect used.  They are commonly used to tag other *strings* to
identify their language in a machine-readable manner.

The *language tag* *shall* match the `Language-Tag`
production from &#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)],
or from any future RFC published by the IEFT that obsoletes
&#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)] (hereinafter
referred to as RFC 5646's successor RFC), and *should* be valid, as
defined in §2.2.9 of &#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)].

Valid *language tags* have the meaning that is assigned to them by
&#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)] and any successor
RFC.  Applications *may* discard any *language tag* that is not
well-formed and replace it with `und`, meaning a undetermined language,
but *must not* discard any *language tag* that is well-formed even if it
is not valid.  

{.note ...} &#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)] says
that to be valid, a *language tag* *must* consist of tags that have
been registered in the &#x5B;[IANA Lang 
Subtags](http://www.iana.org/assignments/language-subtag-registry)]
registry.  This is freely available online in a machine-readable form
defined in §3.1.1 of 
&#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)], and gives the
meaning of every tag.  Currently it includes:

*  two-letter language tags from [ISO 639-1];
*  three-letter language tags from [ISO 639-2]  (the "terminology" codes
   where they differ from the "bibliographic" codes), [ISO 639-3] and 
   [ISO 639-5] for languages with no two-letter code; 
*  four-letter script tags from [ISO 15924]; 
*  two-letter country codes currently assigned in [ISO 3166-1], together
   with certain formerly assigned or reserved codes; 
*  three-digit codes for supranational geographical areas and
   exceptionally countries from [UN M.49]; and
*  a small number of legacy tags that have been grandfathered into the
   scheme.

The meanings of codes in the source ISO standards may change over time,
but the procedure set out in §3.4 of &#x5B;[RFC
5646](https://tools.ietf.org/html/rfc5646)] governing the addition of
tags to &#x5B;[IANA Lang
Subtags](http://www.iana.org/assignments/language-subtag-registry)]
ensures the meanings there stable.  This particularly affects 
[ISO 3166-1] country codes which historically have been reused, and may 
result in a gradual divergence between and &#x5B;[IANA Lang
Subtags](http://www.iana.org/assignments/language-subtag-registry)].
Applications *should* therefore avoid using [ISO 3166-1] codes that have
not been registered in &#x5B;[IANA Lang
Subtags](http://www.iana.org/assignments/language-subtag-registry)]. 
{/}

{.example ...} A *string* tagged with the *language tag* `hu-CS` *must*
be interpreted by a *conformant* application as being in the Hungarian
language localised for use in the former state of Serbia and Montenegro,
because this is how `hu` and `CS` are listed in &#x5B;[IANA Lang
Subtags](http://www.iana.org/assignments/language-subtag-registry)].
The code `CS` is perhaps better known as representing the former state
of Czechoslovakia and appears in older lists of [ISO 3166-1] country
codes as such, but neither IANA nor FHISO recognise this former meaning.

This is one of five country codes whose meaning has materially changed
in [ISO 3166-1], the other four being `AI`, `BQ`, `GE` and `SK`.  In
each case, because the reuse occurred before the creation of &#x5B;[IANA Lang
Subtags](http://www.iana.org/assignments/language-subtag-registry)], it
is the current meaning that is listed in &#x5B;[IANA Lang 
Subtags](http://www.iana.org/assignments/language-subtag-registry)].
If there is further reuse of country codes in the future, &#x5B;[RFC
5646](https://tools.ietf.org/html/rfc5646)] requires that the current
meaning of the tag be retained and a numeric code be given to the new
country in &#x5B;[IANA Lang 
Subtags](http://www.iana.org/assignments/language-subtag-registry)].
{/}

A *conformant* application *may* convert any *language tag* into its
canonical form, as defined by §4.5 of &#x5B;[RFC
5646](https://tools.ietf.org/html/rfc5646)] or an equivalent section of
a successor RFC.  

{.note} The chief purpose of canonical form is to replace deprecated
language codes and other subtags with the value found in the
`Preferred-Value` field in [IANA Lang Subtags].  It never results in the
removal of script subtag, even when they are the default script for the
language as defined by a `Suppress-Script` field.

{.example}  The *language tag* `iw` is listed in [IANA Lang Subtags] as
a deprecated language code for Hebrew which has now been removed from
[ISO 639-1].  Its `Preferred-Value` field is `he`, so an application
*may* replace `iw` with `he`.

A *conformant* application *may* alter a *language tag* in any other way
that leaves its canonical form unchanged when compared in a
case-insensitive manner.

{.note}  Such changes are permitted for three reasons.  First, it allows
applications to revert new tags to older deprecated forms when exporting
data to an older application.  Secondly, it allows applications to
remain *conformant* even if they are basing conversions on an outdated
copy of the [IANA Lang Subtags] registry.  This is because §3.4 of
&#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)] only allows
certain compatible changes to the registry.  Thirdly, it allows
applications to apply the conventional capitalisation of *language tags*
defined in §2.1.1 of 
&#x5B;[RFC 5646](https://tools.ietf.org/html/rfc5646)].

### Language-tagged strings                       {#lang-tagged-strings}

A **language-tagged string** is type of *tagged string* with exactly one
*tag* which is a *language tag* and *must* be present.  The *language
tag* identifies the language in which the *tagged string* is written.  

{.example}  The *string* "Les réseaux familiaux dans l'aristocratie
byzantine" would be a *language-tagged string* if accompanied by the
*language tag* `fr`, representing the French language.

{.example ...}  *Language-tagged strings* are widely encountered in XML,
where the `xml:lang` attribute provides the *language tag*.  For
example,

    <title xml:lang="de">Europäische Stammtafeln</title>
{/}

If no *language tag* is present in the serialisation of a
*language-tagged string*, either explicitly or implicitly, a default
*language tag* of `und` *must* be used.  This is defined in 
&#x5B;[ISO 639-2](http://www.loc.gov/standards/iso639-2/)] to mean an
undetermined language. 

{.note}  This wording is intended to allow serialisation formats to
have a default *language tag* which implicitly applies to all
*strings* in a document or section of a document.  XML does this by
making the `xml:lang` attribute apply to all child elements.

## Terms                                                        {#terms}

A **term** is a form of identifier used in FHISO standards to represent
a concept which it is useful to be able to reference.  A *term*
consists of a unique, machine-readable identifier, known as the **term
name**, paired with a clearly-defined meaning for the concept or idea
that it represents.  *Term names* *shall* take the form of an IRI
matching the `IRI` production in §2.2 of
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)]. 

{.example ...} This standard uses *terms* to name *datatypes*, as defined in
{§datatypes} of this standard, and also to name *classes* and *properties*,
defined in {§classes} and {§properties}.   For example, {§integer} of
this standard defines a *datatype* for representing integers.  This
*datatype* is identified by a *term* whose *term name* in *prefix*
notation is `xsd:integer`.  This is short for the following IRI:

    http://www.w3.org/2001/XMLSchema#integer
{/}

{.note} IRIs have been chosen in preference to URIs because it is
recognised that certain culture-specific genealogical concepts may not
have English names, and in such cases the human-legibility of IRIs is
advantageous.  URIs are a subset of IRIs, and all the *terms* defined in
this suite of standard are also URIs.

*Term names* are compared using the "simple string comparison" algorithm
given in §5.3.1 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)].  If a *term
name* does not compare equal to an IRI known to the application,
the application *must not* make any assumptions about the
*term*, its meaning or intended use, based on the form of the IRI or any
similarity to other IRIs.

{.note} This comparison is a simple character-by-character comparison,
with no normalisation carried out on the IRIs prior to comparison.  It
is also how XML namespace names are compared in 
&#x5B;[XML Names](https://www.w3.org/TR/xml-names11/)].

{.example ...}  The following IRIs are all distinct for the purpose of
the "simple string comparison" algorithm given in §5.3.1 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)], , even though an
HTTP request to them would fetch the same resource.

    https://éléments.example.com/nationalité
    HTTPS://ÉLÉMENTS.EXAMPLE.COM/nationalit%C3%A9
    https://xn--lments-9uab.example.com/nationalit%c3%a9

{/}

An IRI *must not* be used as a *term name* unless it can be converted to
a URI using the algorithm specified in §3.1 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)], and back to a IRI
again using the algorithm specified in §3.2 of 
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)], to yield the
original IRI.

{.note}  This requirement ensures that *term names* can be used in a
context where a URI is required, and that the original IRI can be
regenerated, for example for comparison with a list of known IRIs.  The
vast majority of IRIs, including those in non-Latin scripts, have this
property.  The effect of this requirement is to prohibit the use of IRIs
that are already partly converted to a URI, for example through the use
of unnecessary percent or punycode encoding.

{.example}  Of the three IRIs given in the previous example on how to
compare IRIs, only the first may be used as a *term name*.  The second
and third are prohibited as a result of the unnecessary
percent-encoding, and the third is additionally prohibited as a result
of unnecessary punycode-encoding.

The *terms* defined in FHISO standards all have *term names* that begin
`https://terms.fhiso.org/`.  Subject to the requirements in the
applicable standards, third parties may also define additional *terms*.
It is *recommended* that any such *terms* use either the `http` or
preferably the `https` IRI scheme defined in §2.7.1 and §2.7.2 of
&#x5B;[RFC 7230](https://tools.ietf.org/html/rfc7230)] respectively, and
an authority component consisting of just a domain name or subdomain
under the control of the party defining the *term*.

{.note ...} An `http` or `https` IRI scheme is *recommended* because the
IRI is used to fetch a resource during *discovery*, and it is desirable
that applications implementing *discovery* should only need to support a
minimal number of transport protocols.  URN schemes like the `uuid`
scheme of &#x5B;[RFC 4122](https://tools.ietf.org/html/rfc4122)] are
*not recommended* as they do not have transport protocols that can be
used during *discovery*.

The preference for a `https` IRI is because of security considerations
during *discovery*.  A man-in-the-middle attack during *discovery* could
insert malicious content into the response, which, if undetected, could
cause an application to process user data incorrectly, potentially
discarding parts of it or otherwise compromising its integrity.  It is
harder to stage a man-in-the-middle attack over TLS, especially if
public key pinning is used per 
&#x5B;[RFC 7469](https://tools.ietf.org/html/rfc7469)].
{/}

### IRI resolution                                           {#iri-resn}
 
It is *recommended* that an HTTP `GET` request to a *term name* IRI with
an `http` or `https` scheme (once converted to a URI per §4.1 of
&#x5B;[RFC 3987](https://tools.ietf.org/html/rfc3987)]), *should* result
in a 303 "See Other" redirect to a document containing a human-readable
definition of the *term* if the request was made without an `Accept`
header or with an `Accept` header matching the format of the
human-readable definition.  It is further *recommended* that this
format should be HTML, and that documentation in alternative formats
*may* be made available via HTTP content negotiation when the request
includes a suitable `Accept` header, per §5.3.2 of 
&#x5B;[RFC 7231](//tools.ietf.org/html/rfc7231)].

{.note}  A 303 redirect is considered best practice for &#x5B;[Linked
Data](http://linkeddatabook.com/editions/1.0/)], so as to avoid
confusing the *term name* IRI with the document containing its
definition, which is found at the post-redirect URL.  The *terms*
defined in this suite of standards are not specifically designed for
use in Linked Data, but the same considerations apply.

Parties defining *terms* *should* arrange for their *term name* to
support **discovery**.  This when an HTTP `GET` request to a *term name*
IRI with an `http` or `https` scheme, made with an appropriate `Accept`
header, yields 303 redirect to a machine-readable definition of the
*term*.  

{.note}  This standard does not specify a specific version of HTTP, but
at the current time, even though HTTP/2 is becoming more popular, HTTP
1.1 is the most widely implemented version of HTTP.  While this remains
true, applications and discovery servers are encouraged to support HTTP
1.1.

This standard does not define a *discovery* mechanism, but it
is *recommended* that parties defining *terms* support FHISO's [Triples
Discovery] mechanism, and *may* additionally support other mechanisms.
Support for *discovery* by applications is *optional*.

{.example ...}  Suppose an application wants to perform *discovery* on 
the hypothetical `https://example.com/events/Baptism` *term* used in
several later examples in this standard.  If the application supports 
FHISO's [Triples Discovery] mechanism, which uses [N-Triples] as its
serialisation format, together with some other hypothetical *discovery*
mechanism using the `application/x-discovery` MIME type, but prefers to
use [Triples Discovery], it might make the following HTTP request:

    GET /events/Baptism HTTP/1.1
    Host: example.com
    Accept: application/n-triples, application/x-discovery; q=0.9

In this example, the `q=0.9` in the `Accept` header is a quality value
which, per §5.3 of &#x5B;[RFC 7231](//tools.ietf.org/html/rfc7231)],
indicates that the `x-discovery` format is less preferred than
`n-triples` which by default has a quality value of 1.0.

If the server supports `n-triples`, it *must* respond with a 303
redirect:

    HTTP/1.1 303 See Other
    Location: https://example.com/events/Baptism.n3
    Vary: Accept

In this case the redirect is to the original IRI but with `.n3`
appended, however the actual choice of IRI is up to the party defining
the *term* and running the `example.com` web server.  When a server's
response is dependent on the contents of an `Accept` header, §7.1.4 of
&#x5B;[RFC 7231](//tools.ietf.org/html/rfc7231)] says that this *should*
be recorded in a `Vary` header, as it is in this example.

The application would normally then make a second HTTP request to follow
the redirect:

    GET /events/Baptism.n3 HTTP/1.1
    Host: example.com
    Accept: application/n-triples, application/x-discovery; q=0.9

This request uses the same `Accept` header as the first, as HTTP
redirects contain no information about the MIME type of the destination
resource, so at this point the application does not know which
*discovery* mechanism the server is using, or whether the server does
not support *discovery* or HTTP content negotiation and is serving a
human-readable definition.

The server's response to this request should be an N-Triples file
containing information about the `Baptism` *term*.
{/}

A party defining a *term* *may* support *discovery* without using HTTP
content negotiation on their web server by serving a machine-readable
definition of the *term* unconditionally (which *should* be served via a
303 redirect), however it is *recommended* that such servers implement
HTTP content negotiation respecting the `Accept` header.

### Namespaces                                             {#namespaces}

The **namespace** of a *term* is another *term* which identifies a
collection of related *terms* defined by the same party.  The *term
name* of the *namespace* is also referred to as its **namespace name**.
The *namespace name* of the *namespace* of some *term* is found as
follows.

If the *term name* ends with a non-empty fragment identifier, then its
*namespace name* is formed by removing the fragment identifier, leaving
an IRI ending with a `#`.

{.example ...}  This standard uses a *datatype* identified by the
following *term name* IRI:
 
    http://www.w3.org/2001/XMLSchema#integer

This concludes with a fragment identifier, "`integer`", and therefore
its *namespace name* is its *term name* with the fragment identifier
removed:

    http://www.w3.org/2001/XMLSchema#
{/}

Otherwise, if the *term name* ends with a non-empty path segment,
then its *namespace name* is formed by removing the path segment,
leaving an IRI ending with a `/`.

{.example ...}  This standard defines a *property* identified by the
following *term name* IRI:

    https://terms.fhiso.org/types/pattern

This concludes with a path segment, "`pattern`", and therefore its
*namespace name* is its *term name* with the path segment removed:

    https://terms.fhiso.org/types/
{/}

Otherwise, the *namespace* is undefined.

{.note}  This means the *namespace* of a *namespace* is necessarily
undefined, as *namespace names* always end with a `#` or `/`, meaning
they end with either an empty fragment identifier or an empty path
segment.

### Prefix notation                                       {#prefix-notn}

*Term names* are sometimes referred using **prefix notation**.  This is
a system whereby **prefixes** are assigned to *namespace names* which
occur frequently in *term names*.  Then, instead of writing the *term
name* in full, the leading portion of the *term name* equal to the
*namespace name* is replaced by its *prefix* followed by a colon
(U+003A) separator.

{.example}  The *term name* `http://www.w3.org/2001/XMLSchema#string`
is used in several places in this standard.  Instead of writing
this in full, if the `xsd` *prefix* is bound to its *namespace name*
`http://www.w3.org/2001/XMLSchema#`, this IRI can be written in
*prefix form* as `xsd:string`.

