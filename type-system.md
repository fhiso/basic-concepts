---
title: Type System for Genealogical Standards
date: 20 April 2020
author:
    - Luther Tychonievich
    - Richard Smith
numbersections: true
...

# Type System for Genealogical Standards

{.ednote ...} This is a **working draft** of a standard covering 
type systems that are expected to be used in multiple standards.
This document is not endorsed by the FHISO membership, and may be
updated, replaced or obsoleted by other documents at any time.

The public [tsc-public@fhiso.org](https://tech.fhiso.org/tsc-public)
mailing list is the preferred place for comments, discussion and other
feedback on this draft.

--------------           ---------------------------------------------
Latest public version:   `https://fhiso.org/TR/basic-concepts`
This version:            *URL to be determined*
Previous version:        `https://fhiso.org/TR/basic-concepts-20180316`
--------------           ---------------------------------------------
{/}

FHISO's **Type System for Genealogical Standards** standard defines
various underlying concepts that are used in many genealogical standards,
and whose definitions do not logically belong in any one particular
higher-level standard.  Having a single definition of these concepts
eliminates the possibility of incompatibilities between standards
arising due to small differences in these basic concepts.

The abstract notion of an *entity* is used in practically all standards,
and a standard definition is given in {§entities}
along with two common representations of *entities*: *terms* and *literals*.
The notion of a *literal set*, useful for example in translating names, is given in {§literal-sets}.

The concepts of a *classes* and *properties* are defined in
{§classes} and {§properties}.  They provide an infrastructure for defining extensions
to FHISO standards and new, compatible standards in such a way that
applications can use a *discovery* mechanism to find out about unknown
components, allowing them to be processed.
To assist in providing defaults and specialization, notions of *sub*- and *super*-*classes*, *types*, and *properties* are defined in {§inheritance}.
Two common *class*-constructing tools are also provided: *lists* in {§lists} and *unions* in {§unions}.
The facilities in these sections will primarily be of use
to parties defining extensions or implementing *discovery*.

Definitions of standard *entities* and *datatypes*
which may be useful in many standards
are given in {§standard-entity} and {§standard-datatype}.


## Conventions used

Where this standard gives a specific technical meaning to a word or
phrase, that word or phrase is formatted in bold text in its initial
definition, and in italics when used elsewhere.
The key words **must**, **must not**, **required**, **shall**, 
**shall not**, **should**, **should not**, **recommended**,
**not recommended**, **may** and **optional** in this standard are to be
interpreted as described in
&#x5B;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it
obeys all the requirements and prohibitions contained in this
document, as indicated by use of the words *must*, *must not*,
*required*, *shall* and *shall not*, and the relevant parts of its
normative references.  Standards referencing this standard *must not*
loosen any of the requirements and prohibitions made by this standard,
nor place additional requirements or prohibitions on the constructs
defined herein.  

{.note} Derived standards are not allowed to add or remove requirements
or prohibitions on the facilities defined herein so as to preserve
interoperability between applications.  Data generated by one
*conformant* application must always be acceptable to another
*conformant* application, regardless of what additional standards each
may conform to. 

If a *conformant* application encounters data that does not conform to
this standard, it *may* issue a warning or error message, and *may*
terminate processing of the document or data fragment.

This standard depends on FHISO's **Basic Concepts for Genealogical
Standards** standard.  To be *conformant* with this standard, an
application *must* also be *conformant* with [Basic Concepts].  Concepts
defined in that standard are used here without further definition.

{.note} In particular, precise meaning of *string*, *character*, 
*term*, *tagged string*, and *language tag* are given in [Basic Concepts].

Indented text in grey or coloured boxes does not form a normative part
of this standard, and is labelled as either an example or a note.  

{.ednote} Editorial notes, such as this, are used to record outstanding
issues, or points where there is not yet consensus; they will be
resolved and removed for the final standard.  Examples and notes will be
retained in the standard.

This standard uses *prefix notation* when discussing specific *terms*.
The following *prefix* bindings are assumed in this standard:

------           -----------------------------------------------
`rdf`            `http://www.w3.org/1999/02/22-rdf-syntax-ns#`
`rdfs`           `http://www.w3.org/2000/01/rdf-schema#`
`xsd`            `http://www.w3.org/2001/XMLSchema#`
`types`          `https://terms.fhiso.org/types/`
------           -----------------------------------------------

{.note}  The particular *prefix* assigned above have no relevance
outside this standard document as *prefix notation* is not used in the
formal type system defined by this standard.  This notation is simply a
notational convenience to make the standard easier to read.


## Entities and their representation {#entities}

An **entity** is a single identifiable concept.

This standard provides two ways to represent an *entity*:
using a *term* or a *literal*;
other standards *may* add additional ways to represent *entities*.

### Terms {#terms}

A **term**, as defined in [Basic Concepts], is an IRI that identifies an *entity*.

Multiple *terms* may identify the same *entity*; such *terms* are said to be **aliases**.
A new *alias* for an *entity* *should not* be introduced where an existing *term* for that *entity* is known.

Not all IRIs are *terms*: to be a *term*, an IRI *must* identify a single *entity* independently of the context in which the IRI appears. 

{.example} Relative IRIs and blank-node identifiers are IRIs, but are not *terms*.


### Literals

A **datatype** is an *entity* that describes a mapping between *strings* and *entities*.
A *term* identifying a *datatype* is called a **datatype name**.
A *datatype name* that is a *tag* in a *tagged string* is called a **datatype tag**.

The set of *strings* that a *datatype* interprets as valid values is called the *datatype*'s **lexical space**.

The *datatype* defines exactly one *entity* each *string* in the *datatype*'s *lexical space* represents.
Multiple *strings* *may* represent the same *entity*;
if so, the *datatype* *may* identify one such representation as the *entity*'s **canonical representation**.
A *conformant* application *must not* attach any significance
to which of the alternative lexical representations is used
and *should* the use *canonical representation* where possible.

A **literal** is a *tagged string* where one *tag* is a *datatype tag* and the *string* is in the *lexical space* of the *datatype* which that *datatype tag* identifies.
A *literal* is a representation of the *entity* which the *string* represents according to that *datatype*.

Every *literal* also has a *language tag*, which *may* be provided implicitly and *shall* be `zxx` if language is not a meaningful concept for *entities* described by the *literal*'s *datatype*.
A *datatype* whose *lexical space* could contain elements of multiple human languages is called a **language-tagged datatype**.
A *datatype* that is not a *language-tagged datatype* is called a
**non-language-tagged datatype**.

*Terms* form a *non-language-tagged datatype* whose *lexical space* is a subset of IRIs; thus each *term* is a *literal*.

### Literal sets {#literal-sets}

A **literal set** is a set of *literals* that are presented together and all identify the same *entity*.

When receiving a *literal set*, a *conformant* application *must not* discard any *literal* from the set unless it retains enough information to recreate it or another *literal* with the same *datatype* and *language tag*.
An application *must not* rely on reconstructing a *literal* of a given *language tag* from another *literal* with a different *language tag* unless the construction process used is able to recreate the exact same linguistic representation.

{.example ...} FHISO's current draft microformat for creator names might be used to create the following *literal set* for the name of one of the authors of this document

*datatype tag*      *language tag*  *string*
--------------      ---------       ------------------------------------------
`cev:CeatorsName`   `en`            `Tychonievich, Luther | Tychonievich`
`cev:CeatorsName`   `en`            `Tychonievich, Luther`
`cev:CeatorsName`   `ja-Latn`       `Taikonevizu Ruteru | Taikonevizu`
`cev:CeatorsName`   `ja`            `タイコネヸズ ルテル | タイコネヸズ`
`elf:PersonalName`  `en`            `Luther /Tychonievich/`

Because the first two use the same *language tag* and *datatype*, only one need be stored.
Because the `en` and `ja` versions cannot be created from one another, both must be stored.
If the application knows the standard Katakana-to-Romanji mapping, the `ja-Latn` can be created from `ja` and can thus be discarded; otherwise both must be preserved.
The last uses a different *datatype*, and should be preserved unless the application knows how to covert between the two *datatypes*.
{/}

Every *literal* is also a *literal set* with one element.

### Patterns

The *lexical space* of a *datatype* *may* be difficult or impossible to write code to fully specify.

{.example} Leap seconds are inserted into the Gregorian calendar based on observation. As such, it is not possible to know if a value with the time part "`23:59:60`" is in the *lexical space* of a Gregorian date-time *datatype* without knowing if a leap second was inserted on that particular date or not.

A *datatype* *may* be accompanied by a **pattern**,
an *entity* representing a readily-computed superset of the *lexical space* of the *datatype*.
A *datatype* for representing *patterns* is given in [FHISO Patterns].

A *datatype* with a *pattern* other than "`.*`" is known as a **structured datatype**,
while one with no *pattern* or a *pattern* of "`.*`" is known as an **unstructured datatype**.


## Classes and their representation {#classes}

A **class** is an *entity* identifying a set of *entities* defined by a particular context or use the *entities* share.
An *entity* is said to be a **member** of a *class* if the context or use of the *class* applies to the *entity*.

The *class* that can be represented by a particular *datatype* is called the **value space** of that *datatype*.

A **class name** is a *term* that identifies a *class*.

## Properties and their representations {#properties}

A **property** of an *entity* is a particular piece of information about that *entity*.
The *entity* being defined is called the **subject** of the *property*.
In addition to the *subject*, every *property* has both

*  a **predicate**, which is the *entity* identifying the nature of the information in the *property*; and
*  a **direct object**, which is the information about the *subject* of the *property*.

The **domain** of a *predicate* is the *class* of *subjects* to which a *property* with that *predicate* may apply.

The **range** of a *predicate* is the *class* of *direct objects* it can be paired with.

A **statement** is a representation of a *property*
using a *term* called the **property name** to identify the *predicate*
and a *literal set* called the **property value** to identify the *direct object*.
The representation of the *subject* of a *statement* may vary between standards and is not specified by this standard.

A *term* introduced to be a *property name* is called a **property term**.

<!--
### Characteristic properties

{.ednote} Revisit this entire section

The context or use case defining an *entity class* may entail that all *members* of that *entity class* have at least one *property* with a particular *predicate*.
If so, that *predicate* is said to be a **characteristic predicate** of the *entity class*.

A standard may identify a *characteristic predicate* of an *entity class* to be a **required property**,
meaning a *property* with that *predicate* *must* be provided when defining a *term* in that *entity class*.  
-->


## Sub- and super-classes, datatypes, and properties {#inheritance}

One *class* may be a **subclass** of another *class*.
The later *class* is called the **superclass** of the former *class*.
The defining context of a *subclass* is a more specialised version of the context denoted by its *superclass*.
Thus, every *member* of the *subclass* is also a *member* of the *superclass*.

One *datatype* may be a **subtype** of another *datatype*.
The latter *datatype* is called the **supertype** of the former.
The *value space* of the *subtype* *shall* be a *subclass* of the *value space* of the *supertype*.
Each *string* in the *lexical space* of the *subtype* *shall* also be in the *lexical space* of the *supertype*, and *shall* represent the same *entity* in both *datatypes*.

One *predicate* may be a **subproperty** of another *predicate*.
The latter *predicate* is called the **superproperty** of the former.
The *domain* of the *subproperty* *shall* be a *subclass* of the *domain* of the *superproperty*.
The *range* of the *subproperty* *shall* be a *subclass* of the *range* of the *superproperty*.
Each *subject* that has a *property* with the *subproperty* as its *predicate*
also has a *property* with the *superproperty* as its predicate with the same *direct object* for both *properties*.

### Trivial super-classes, datatypes, and properties

Every *class* has two **trivial superclasses**:
the *class* itself and the *class* of all *entities*.
A *superclass* that is not a *trivial superclass* is called a **non-trivial superclass**.

A *datatype* has one **trivial supertype**:
the *datatype* itself.
A *supertype* that is not a *trivial supertype* is called a **non-trivial supertype**.

Every *predicate* has one **trivial superproperty**:
the *predicate* itself.
A *superproperty* that is not a *trivial superproperty* is called a **non-trivial superproperty**.

If an *entity* has two *properties* with the same *direct object*,
where one *property*'s *predicate* is a *superproperty* of the other,
the *property* with the *superproperty* is said to be a **trivial property** of the *entity*.
A *property* that is not a *trivial property* is called a **non-trivial property**.


## Lists {#lists}

A **list** is an ordered sequence of entities which may contain duplicates.
Every list has a finite **length**, which is a non-negative integer.
For each integer *k* between 1 and the *length* of the *list*, inclusive,
there is exactly one *entity* contained in the list that is called the __*k*^th^ item__ of the *list*; *k* is called an **index** in the *list* of that *entity*.
If a single *entity* appears in the *list* more than once, it will have more than one *index* in the *list*.
An *entity* is called an **item** of a *list* if it is a *k^th^ item* of the *list* for some *k*.

{.note} The above formalizes the common notion of a list, array, or tuple in most programming languages, and the concept of a finite sequence, enumeration, or tuple in mathematics. It uses 1-based (not 0-based) indexing. It does not allow skipped indexes or missing items.

{.ednote} Is "*item*" the best word? Both "element" an "item" are used interchangeably by <https://www.w3.org/TR/xmlschema-2/>; "member" is used <https://www.w3.org/TR/rdf-schema/>

A *list* with length 0 is said to be **empty**.

A *class* is said to be an **item type** of a *list*
if every *item* in the *list* is a *member* of a *class*.
Every *class* is an *item type* of an *empty* *list*.

{.note} This specification does not define "before", "after", "earlier", "later", "first", "last", etc. Standards requiring these notions may refer to "a lesser *index*" or the like.


### Delimited Lists

A **delimited list type** is a *datatype* defined by
another *datatype*, called the *delimited list type*'s **item datatype**,
and a *pattern*, called the *delimited list type*'s **delimiter**.
The *value space* of the *delimited list type* is a set of *lists* whose *item type* is the *item datatype*'s *value space*.
A *literal* with a *delimited list type* as its *datatype* is called a **delimited list**.

A *string* in the *lexical space* of a *delimited list type*
is mapped to an *entity* by splitting the *string* on occurrences of the *delimiter* and mapping the portions of the *string* between *delimiters* into *items* of a *list* using the *item datatype*.
If the empty *string* is not in the *lexical space* of the *item datatype*, empty *strings* are skipped during this conversion.

{.ednote} TO DO: add "split" as a defined operation in [FHISO Patterns].
We could add it here, but it has enough nuances that I believe it better belongs there.

*Delimited list types* *should* be defined with a *delimiter* that is not a substring of any string in the *item datatype*'s *lexical space*.
Failure to do so may result in only a subset of the *item datatype*'s *value space* being representable as *items* of the *list*.

{.note} [XSD Pt2]'s lists are *delimited lists* with *delimiter* "`[ \t\n\r]+`".



## Unions {#unions}

The **union** of a set of *classes* is a *class* defined to have as a *member* exactly those *entities* that are *members* of at least one *class* in the set.

The **union** of a *list* of two or more of *datatypes* is a *datatype* whose *lexical space* contains all *strings* in the *lexical space* of any of the *items* in the *list*.
Each *string* in the *union*'s *lexical space* maps to one *entity*, as defined by an *item* in the *list* which has the *string* in its *lexical space*.
If the *string* is in the *lexical space* of multiple *items*, the *item* with the least *index* in the *list* is used.

{.note} The *union* of a *list* of *datatypes* is a *supertype* of the *1^st^ item* in the *list*, but in general not a *supertype* of a later *item* unless that *item*'s *lexical space* is disjoint with the *lexical spaces* of all preceding *items*.

{.note} This definition of the *union* of *datatypes* is consistent with [XSD Pt2].

{.ednote} [XSD Pt2] 2.4.1.3 refers to order, not index, but does not fully define what order means in this context. It is not the value order implied by section 2.2.3 of that document; it appears instead to be the order of elements in the underlying list. That list-position order is defined in this document using the notion of indexes, leading to the above definition.

{.ednote} Neither the above nor [XSD Pt2] requires that each datatype in the list actually contribute meaning. For example, the union of the list (`xsd:string`, `xsd:integer`) is allowed, but is actually equal to `xsd:string`. Do we want to address this?

{.ednote} Do we have a motivating use-case for datatype unions? Nullable types are the most common use I can find elsewhere; not sure if they apply for us or not. If we cannot identify their use, I'd rather remove them as unnecessary complexity.



## Standard entities    {#standard-entity}

Several *entities* are defined here for use in FHISO standards.
Each is given with a canonical *term* that *should* be used to identify the *entity* in preference of other *terms*.

### Standard classes        {#standard-class}

#### Classes

The *class* of all *classes* is `rdfs:Class`.

: Class definition

------              -----------------------------------------------------------
Name                `http://www.w3.org/2000/01/rdf-schema#Class`
Type                `http://www.w3.org/2000/01/rdf-schema#Class`
Superclass          `http://www.w3.org/2000/01/rdf-schema#Resource`
Required properties `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`
------              -----------------------------------------------------------


#### Datatypes

The *class* of all *datatypes* is `rdfs:Datatype`.

: Class definition

------              -----------------------------------------------------------
Name                `http://www.w3.org/2000/01/rdf-schema#Datatype`

Type                `http://www.w3.org/2000/01/rdf-schema#Class`

Superclass          `http://www.w3.org/2000/01/rdf-schema#Resource`

Required properties `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`<br/>
                    `https://terms.fhiso.org/types/pattern`
------              -----------------------------------------------------------


Common data formats, including RDF, allow a *datatype name* to be used
in contexts expecting a *class name*; when so used, these formats implicitly convert the *datatype name* into reference to the *datatype*'s *value space*.

{.note} [RDF Schemas] goes so far as to codify this usage by saying the *superclass* of `rdfs:Datatype` is `rdfs:Class`, despite RDF defining a datatype as a (lexical space, value space, lexical-to-value mapping) tuple and a class as a set of entities.

{.ednote} To be clear, RDF's "datatype is a subclass of class" claim, if interpreted literally, is the mathematically-invalid claim that a set of tuples is a set of sets:
$$\big\{(\ell,v,f) \;\big|\; (\ell \subseteq \Sigma^*) \land (v \in C) \land (f:\ell\rightarrow v) \big\} \quad \subseteq \quad C$$

#### Delimited list types

The *class* of all *delimited list types* is `types:DelimitedList`.

: Class definition

------              -----------------------------------------------------------
Name                `https://terms.fhiso.org/types/DelimitedList`

Type                `http://www.w3.org/2000/01/rdf-schema#Class`

Superclass          `http://www.w3.org/2000/01/rdf-schema#Datatype`

Required properties `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`<br/>
                    `https://terms.fhiso.org/types/pattern`<br/>
                    `https://terms.fhiso.org/types/delimiter`<br/>
                    `http://www.w3.org/2001/XMLSchema#itemType`
------              -----------------------------------------------------------


#### Entities

The *class* of all *entities* is `rdfs:Resource`.

: Class definition

------              -----------------------------------------------------------
Name                `http://www.w3.org/2000/01/rdf-schema#Resource`
Type                `http://www.w3.org/2000/01/rdf-schema#Class`
Required properties `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`
------              -----------------------------------------------------------


`rdfs:Resource` is a *trivial superclass* of every *class*.
The only *superclass* of `rdfs:Resource` is itself.


#### Lists

The *class* of all *lists* is `types:List`.

: Class definition

------              -----------------------------------------------------------
Name                `https://terms.fhiso.org/types/List`

Type                `http://www.w3.org/2000/01/rdf-schema#Class`

Required properties `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`<br/>
                    `https://terms.fhiso.org/types/itemType`<br/>
                    `http://www.w3.org/2001/XMLSchema#length`
------              -----------------------------------------------------------

{.note} We do not use `rdf:List` because it is instead the class of singly-linked nodes; while a singly-linked node can be used to create a *list*, it can also be used in other ways.

{.note} We do not use `xsd:list` because it is instead the set of *delimited list types*.



#### Predicates

The *class* of all *predicates* is `rdf:Property`.

: Class definition

------              -----------------------------------------------------------
Name                `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`

Type                `http://www.w3.org/2000/01/rdf-schema#Class`

Required properties `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`<br/>
                    `http://www.w3.org/2000/01/rdf-schema#range`
------              -----------------------------------------------------------



### Standard properties     {#standard-property}

#### Delimiter of a delimited list type

The *property term* representing the *delimiter* of a *delimited list type* is `type:delimiter`.

: Property definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/types/delimiter`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `https://terms.fhiso.org/types/Pattern`
Domain           `https://terms.fhiso.org/types/DelimitedList`
------           -----------------------------------------------

#### Domain of a property

The *property term* representing the *domain* of a *predicate* is `rdfs:domain`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2000/01/rdf-schema#domain`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Class`
Domain           `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
------           -----------------------------------------------

#### Item of a list

The *property term* representing an *item* of a *list* is `rdfs:member`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2000/01/rdf-schema#member`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Resource`
Domain           `https://terms.fhiso.org/types/List`
------           -----------------------------------------------

The *property term* representing the *k^th^ item* of a *list* is the concatenation of the `rdf:` prefix, an underscore U+005F, and the *canonical representation* of *k* in the `xsd:integer` *datatype*.
All such *predicates* are *subproperties* of `rdfs:member`
and share `rdfs:member`'s *domain* and *range*.

{.example} "`http://www.w3.org/1999/02/22-rdf-syntax-ns#_3`"
is the *property term* for the *3^rd^ item* of a *list*.

{.note} Although RDF introduces the "`rdf:_`number" *property names*, it only partially defines them because it limits itself to semantics that can be encoded entirely in RDF statements. This standard can be seen as imposing additional requirements on RDF's definition of "`rdf:_`number"

{.ednote} `rdfs:ContainerMembershipProperty` is the *class* of all *k^th^ item* *properties*, but I don't see a need to specify that for FHISO standards.

#### Item datatype of a delimited list datatype

The *property term* representing the *item datatype* of a *delimited list* *datatype* is `xsd:itemType`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2001/XMLSchema#itemType`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Datatype`
Domain           `https://terms.fhiso.org/types/DelimitedList`
------           -----------------------------------------------

#### Item type of a list

The *property term* representing the *item type* of a *list* is `types:itemType`.

: Property definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/types/itemType`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Class`
Domain           `https://terms.fhiso.org/types/List`
------           -----------------------------------------------


#### Length of a list

The *property term* representing the *length* of a *list* is `xsd:length`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2001/XMLSchema#length`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            non-negative integers
Domain           `https://terms.fhiso.org/types/List`
------           -----------------------------------------------

{.note} `xsd:length` is defined more broadly in [XSD Pt2] that just the length of lists: it also counts *characters* in a *string*, octets in binary data, etc.


#### Pattern of a datatype

The *property term* representing the *pattern* of a *datatype* is `types:pattern`.

: Property definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/types/pattern`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `https://terms.fhiso.org/types/Pattern`
Domain           `http://www.w3.org/2000/01/rdf-schema#Datatype`
------           -----------------------------------------------

{.note} We do not use `xsd:pattern`
because its *range* is the set of XSD regular expressions instead of a FHISO patterns.
FHISO patterns are intended to be readily implemented in any programming language, using a different syntax and more limited subset of the components than XSD regular expressions.


#### Range of a property

The *property term* representing the *range* of a *predicate* is `rdfs:range`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2000/01/rdf-schema#range`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Class`
Domain           `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
------           -----------------------------------------------

#### Required property of a class

A standard may declare a *predicate* to be a **required property** of a *class*,
meaning that a *property* with that *predicate* *must* be provided for every *entity* of that *class*.
The *property term* representing a *required property* of a *class* is `types:requiredProperty`.

: Property definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/types/requiredProperty`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Domain           `http://www.w3.org/2000/01/rdf-schema#Class`
------           -----------------------------------------------

*Required properties* of various *classes* used in FHISO standards are included in {§standard-class}.
A *predicate* *must not* be a *required property* of a *class* unless every *member* of the *class* is guaranteed to have at least one *property* with that *predicate*.

#### Superclass of a class

The *property term* representing the *superclass* of an *entity class* is `rdfs:subClassOf`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2000/01/rdf-schema#subClassOf`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Class`
Domain           `http://www.w3.org/2000/01/rdf-schema#Class`
------           -----------------------------------------------

#### Superproperty of a predicate

The *property term* representing a *superproperty* of a *predicate* is `rdfs:subPropertyOf`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2000/01/rdf-schema#subPropertyOf`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Domain           `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
------           -----------------------------------------------

#### Supertype of a datatype

The *property term* representing a *supertype* of a *datatype* is `types:supertype`.

: Property definition

------           -----------------------------------------------
Name             `https://terms.fhiso.org/types/supertype`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Datatype`
Domain           `http://www.w3.org/2000/01/rdf-schema#Datatype`
------           -----------------------------------------------

#### Type of a term

The *property term* representing the *member* of a *class* is `rdf:type`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `http://www.w3.org/2000/01/rdf-schema#Class`
Domain           `http://www.w3.org/2000/01/rdf-schema#Resource`
------           -----------------------------------------------

#### Union of a list of datatypes

The *property term* representing the *list* of *datatypes* that a *union* *datatype* is constructed from is `xsd:union`.

: Property definition

------           -----------------------------------------------
Name             `http://www.w3.org/2001/XMLSchema#union`
Type             `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
Range            `https://terms.fhiso.org/types/List`
Domain           `http://www.w3.org/2000/01/rdf-schema#Datatype`
Range Item Type  `http://www.w3.org/2000/01/rdf-schema#Datatype`
------           -----------------------------------------------

{.note} While [XSD Pt1] does not use `xsd:union` as a predicate per se, it does use it as a defining child element in datatype definitions, roughly matching our notion of *property*.

{.note} The *domain* above is listed as all *datatypes*, not just those normally thought of as unions.
This is because a *datatype* defined by `xsd:union` is just an ordinary *datatype*; there is no "union type" *subclass* of `rdfs:Datatype`.
For example, `xsd:integer` is the *datatype* it is whether it was defined as-is or whether it was initially defined as the union of a negative-integer and non-negative-integer *datatype*.








## Standard datatypes       {#standard-datatype}

Several *datatypes* are described here for use in FHISO standards.


### The `xsd:boolean` datatype

A **boolean** is a *datatype* with precisely two *entities*:
**true** and **false**.
FHISO standards represent *booleans* using the `xsd:boolean` *datatype*
defined in §3.3.2 of [XSD Pt2].
This is a *structured non-language-tagged datatype* which has the following properties:

: Datatype definition

------           -----------------------------------------------
Name             `http://www.w3.org/2001/XMLSchema#boolean`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `true|false|1|0`
Value Space      the two *entities* *true* and *false*
------           -----------------------------------------------

The *lexical space* of this *datatype* includes four *strings*
so that the two logical values of the *datatype* each have two alternative lexical representations.
*True* *may* be represented by either "`true`" or "`1`";
*false* *may* be represented by either "`false`" or "`0`".
The *canonical representations* are "`true`" and "`false`".


### The `xsd:integer` datatype                               {#integer}

FHISO standards represent *integers* using the `xsd:integer` *datatype*
defined in §3.4.13 of [XSD Pt2].
This is a *structured non-language-tagged datatype* which has the following properties:

: Datatype definition

------           -----------------------------------------------
Name             `http://www.w3.org/2001/XMLSchema#integer`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `[+-]?[0-9]+`
Value Space      all integers
------           -----------------------------------------------

This *datatype* *must not* be used for values which are typically but not invariably integers.

This *datatype* can represent arbitrarily large integers,
but unless otherwise stated,
applications *may* opt not to support values that lie outside the range of a 32-bit signed two's-compliment integer (i.e. $-2^{31}$ through $2^{31}-1$ inclusive).
In the event an unsupported value is encountered,
a *conformant* application *may* handle it in an implementation-defined manner,
but *must not* convert it to a different integer.

The *lexical space* of this *datatype*
is the set of all *strings* consisting of a finite-length sequence of one or more decimal digits
(U+0030 to U+0039, inclusive),
optionally preceded by a `+` or `-` sign
(U+002B or U+002D, respectively).

This *datatype* has several alternative representations of each integer value
because leading zeros are permitted,
the `+` sign is optional,
and the value `-0` is permitted.
The *canonical representations* 
do not use the `+` sign,
do not have leading zeros on non-zero values,
and represent zero as "`0`".

### The `types:Term` datatype                                 {#Term}

FHISO standards represent *terms* using the `types:Term` *datatype*.
This is a *structured non-language-tagged datatype* which has the following properties:


: Datatype definition

------           -----------------------------------------------
Name             `ttps://terms.fhiso.org/types/Term`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `[a-zA-Z][a-zA-Z0-9+\-.]*:.*`
Value Space      `http://www.w3.org/2000/01/rdf-schema#Resource`
------           -----------------------------------------------

<!--
`ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )`, see RFC 2234 for definition
-->

This *lexical space* of this *datatype* is limited to *strings* which match the `absolute-IRI` production in §2.2 of [RFC 3987].
Other requirements and recommendations regarding *terms* are given in {§terms} and in [Basic Concepts].

{.note ...} Those requirements and recommendations include

A *compliant* system *must not* introduce a new *literal* with the `xsd:anyURI` *datatype*
unless converting it to a URI
using the algorithm specified in §3.1 of [RFC 3987]
and back to a IRI again
using the algorithm specified in §3.2 of [RFC 3987]
yields the original IRI.

Not all IRIs are *terms*: to be a *term*, an IRI *must* identify a single *entity* independently of the context in which the IRI appears. 
{/}


{.note} We do not use `xsd:anyURI` because its *lexical space* includes relative IRIs, blank node identifiers, and other IRIs that are not valid *terms*.



### The `rdf:langString` datatype                         {#langString}

FHISO standards represent human-readable text using the `rdf:langString` *datatype*
defined in §2.5 of [RDF Schema].
This is an *unstructured language-tagged datatype* which has the following properties:

: Datatype definition

------           -----------------------------------------------
Name             `http://www.w3.org/1999/02/22-rdf-syntax-ns#langString`
Type             `http://www.w3.org/2000/01/rdf-schema#Datatype`
Pattern          `.*`
Value Space      all human-readable *strings*
------           -----------------------------------------------





## References

### Normative references

[Basic Concepts]
:   FHISO (Family History Information Standards Organisation).
    *Basic Concepts for Genealogical Standards*. Richard Smith, ed., 2019.  First public draft.


[FHISO Patterns]
:   FHISO (Family History Information Standards Organisation).
    *The Pattern Datatype*. Luther Tychonievich and Richard Smith, eds., 2018. First public draft.

[RFC 3987]
:   IETF (Internet Engineering Task Force).  *RFC 3987:
    Internationalized Resource Identifiers (IRIs).*  Martin Duerst and
    Michel Suignard, eds., 2005. (See <https://tools.ietf.org/html/rfc3987>.)

[XSD Pt2]
:   W3C (World Wide Web Consortium). *W3C XML Schema Definition Language 
    (XSD) 1.1 Part 2: Datatypes*.  David Peterson, Shudi Gao (高殊镝),
    Ashok Malhotra, C. M. Sperberg-McQueen and Henry S. Thompson, eds., 2012.
    W3C Recommendation.  (See <https://www.w3.org/TR/xmlschema11-2/>.)

### Non-normative references

[RDF Schema]
:   W3C (World Wide Web Consortium). *RDF Schema 1.1*. Dan Brickley and R. V. Guha, eds.,  2014. W3C Recommendation. (See <http://www.w3.org/TR/rdf-schema/>.) 

[XSD Pt1]
:   W3C (World Wide Web Consortium). *W3C XML Schema Definition Language 
    (XSD) 1.1 Part 1: Structures*.  Shudi Gao (高殊镝),
    C. M. Sperberg-McQueen and Henry S. Thompson, eds., 2012.
    W3C Recommendation.  (See <https://www.w3.org/TR/xmlschema11-1/>.)

