---
title: Type Systems for Genealogical Standards
date: 7 November 2019
author:
    - Luther Tychonievich
    - Richard Smith
numbersections: true
...

# Type Systems for Genealogical Standards

{.ednote ...} This is an **early draft** of a standard covering concepts related to type systems that are expected to be used in multiple standards. This document is not endorsed by the FHISO membership, and may be updated, replaced or obsoleted by other documents at any time.

The public [tsc-public@fhiso.org](https://tech.fhiso.org/tsc-public)
mailing list is the preferred place for comments, discussion and other
feedback on this draft.
{/}

FHISO's **Type Systems for Genealogical Standards** standard defines various low-level concepts that are used in many genealogical standards, and whose definitions do not logically belong in any one particular higher-level standard.  Having a single definition of these concepts eliminates the possibility of incompatibilities between standards arising due to small differences in these basic concepts.

The definitions in this standard are of two kinds: a set of definitions of concepts and a set of definitions of how those concepts can be represented in data. This separation of definitions is maintained in part to support standards where some concepts are represented only implicitly.

{.note ...}
This document's conceptual definitions include *entity*, *entity class*, *formal property*, *predicate*, *direct object*, and *value space*.

This document's representation definitions include *class*, *property*, *property name*, *property value*, *property term*, *required property*, *datatype*, *lexical space*, *pattern*, *literal*, *datatype tag*, and *literal value*. It also defines several specific *terms* and *datatypes*.

This document also defines *alias*, *member*, *subclass*, *superclass*, *subject*, and *range*, which apply to both concepts and their representations.
{/}

## Conventions used

Where this standard gives a specific technical meaning to a word or phrase, that word or phrase is formatted in bold text in its initial definition, and in italics when used elsewhere. The key words **must**, **must not**, **required**, **shall**, **shall not**, **should**, **should not**, **recommended**, **not recommended**, **may** and **optional** in this standard are to be interpreted as described in &#x5b;[RFC 2119](https://tools.ietf.org/html/rfc2119)].

An application is **conformant** with this standard if and only if it obeys all the requirements and prohibitions contained in this document, as indicated by use of the words *must*, *must not*, *required*, *shall* and *shall not*, and the relevant parts of its normative references. Standards referencing this standard *must not* loosen any of the requirements and prohibitions made by this standard, nor place additional requirements or prohibitions on the constructs defined herein.

{.note} Derived standards are not allowed to add or remove requirements or prohibitions on the facilities defined herein so as to preserve interoperability between applications. Data generated by one *conformant* application must always be acceptable to another *conformant* application, regardless of what additional standards each may conform to.

If a *conformant* application encounters data that does not conform to this standard, it *may* issue a warning or error message, and *may* terminate processing of the document or data fragment.

This standard depends on FHISO's **Basic Concepts for Genealogical Standards** standard. To be *conformant* with this standard, an application *must* also be *conformant* with [Basic Concepts]. Concepts defined in that standard are used here without further definition.

{.note} In particular, precise meaning of *string*, *language tag*, *term*, *term name*, *IRI*, *prefix notation*, and *prefix* are given in [Basic Concepts].

Indented text in grey or coloured boxes does not form a normative part of this standard, and is labelled as either an example or a note.

{.ednote} Editorial notes, such as this, are used to record outstanding issues, or points where there is not yet consensus; they will be resolved and removed for the final standard.  Examples and notes will be retained in the standard.

The grammar given here uses the form of EBNF notation defined in §6 of &#x5B;[XML](https://www.w3.org/TR/xml11/)], except that no significance is attached to the capitalisation of grammar symbols.  *Conforming* applications *must not* generate data not conforming to the syntax given here, but non-conforming syntax *may* be accepted and processed by a *conforming* application in an implementation-defined manner.

This standard uses *prefix notation*, as defined [Basic Standards], when discussing specific *terms*.  The following *prefix* bindings are assumed in this standard: 

------           -----------------------------------------------
`rdf`            `http://www.w3.org/1999/02/22-rdf-syntax-ns#`
`rdfs`           `http://www.w3.org/2000/01/rdf-schema#`
`xsd`            `http://www.w3.org/2001/XMLSchema#`
`types`          `https://terms.fhiso.org/types/`
------           -----------------------------------------------

{.note}  The particular *prefix* assigned above have no relevance
outside this standard document as *prefix notation* is not used in the
formal data model defined by this standard.  This notation is simply a
notational convenience to make the standard easier to read.


## Entities {#entities}

An **entity** is a single identifiable concept.

{.note} *Entity* is intentionally broad in scope, ranging from concrete historical entities to abstract concepts.

{.example} The person "Julius Caesar, Emperor of Rome" is an *entity* which might appear as a subject in family history research.

{.example} The relationship "primary author of" is an *entity* which might appear in a citation describing a source.

{.example} The concept "numbers represented in base-10 using ASCII digits without place separators" is an *entity* which is formalized by the `xsd:integer` *datatype*.

A *term*, as defined in [Basic Standards], identifies an *entity* by pring it with an *IRI*. Multiple *terms* identifying the same *entity* may exist, but a new *term* for an *entity* *should not* be created if an existing *term* for that *entity* is known. Terms are said to **alias** each other if they refer to the same *entity*.

{.note} *Aliasing* *terms* arise naturally in several situations, including when multiple data models develop *terms* for the same feature independently and when researchers introduce *terms* for the historical *entities* referenced in each of several sources only to later discover they were all the same *entity*.

Nothing prevents an *entity* from being referenced without a *term*, as might occur if the *entity* is implicit from context or is specified using a *datatype* (see {§datatypes}).

{.example ...}
A formatted citation like 

> FHISO (Family History Information Standards Organisation). *The Pattern Datatype*.  First public draft.

can be seen as asserting the author, title, and version of a document; the document is an *entity*, but no *term* or *datatype* is present in the citation to identify it as such; we understand the *entity's* presence implicitly from the context of it being a citation.
{/}

## Classes {#classes}

An **entity class** is an *entity* identifying a particular context or use in which other *entities* may be defined. An *entity* is said to be a **member** of an *entity class* if the context or use of the *entity class* applies to the *entity*.

{.note} *Entity class* is intentionally broad enough to cover both the ideas of a class in the object-oriented sense (the context including the set of members each object of the class contains and their meaning) and a named enumeration (the context being the meaning of the enumeration name). An *entity class* could be used to describe almost any set of *entities*, provided there is some context or use case that defines that set.

A **class** is a *term* that identifies an *entity class*.

The *class* of all *entities* is `rdfs:Resource`.
The *class* of all *entity classes* is `rdfs:Class`.

An *entity class* may be a **subclass** of another *entity class*. The later *entity class* is called the **superclass** of the former *entity class*. The *subclass* denotes a more specialised version of the context denoted by its *superclass*. Thus, every *member* of the *subclass* is also a *member* of the *superclass*.

A *class* is said to be a *subclass* or *superclass* of another *class* if the *classes* identify *entity classes* with that relationship.

Every *class* (including `rdf:Class`) is therefore a **subclass** of `rdfs:Resource`, the *class* of all *entities*.

{.ednote} [Basic Concepts] contains the definition "When a *term* has been defined for use in the context denoted by some *class*, that *class* is referred to as the **type** of the *term*." However, each term can belong to several classes, so why is the one that was contemplated when the *term* was defined special? Perhaps the idea of the "most important" *class* of a *term* is worth adding; perhaps it is instead enough to say that in defining a *term*, at least one non-trivial *class* of the *term* *should* be specified.

## Properties {#properties}

A **formal property** is a particular piece of information that might be provided when defining some *entity*. The *entity* being defined is called the **subject** of the *formal property*. The *formal property* consists of two parts, both of which are *required* to be present:

*  a **predicate**, which is the *entity* identifying the nature of the information in the *property*; and
*  a **direct object**, which is the information about the *subject* of the *property*.

The *class* of all `predicates` is `rdfs:Property`.

The **range** of a *predicate* is the *entity class* of *direct objects* it can be paired with.
The *range* is itself a *formal property* of the *predicate*.

{.ednote} to do: Look up and, where appropriate, mirror the language of RDF in the above.

A **property** identifies a *formal property*.
The *predicate* of the *formal property* is represented by the **property name** of the *predicate*, which is a *term*.
The *direct object* of the *formal property* is represented by the **property value** of the *predicate*, which is either a *term* or *literal value*.
The representation of the *subject* of a *property* may vary across different standards and is not specified by this standard.

A *property* which identifies a *class* to which an *entity* belongs uses the *property name* `rdf:type` and has *range* `rdfs:Class`.

A *property* which identifies the *range* of a *property name* uses the *property name* `rdfs:range` and has *range* `rdfs:Class`.

A *term* introduced to be a *property name* is called a **property term**.
Both `rdf:type` and `rdfs:range` are *property terms*.

*Properties* *shall not* have default *property values* that apply when the *property* is absent; however standards *may* define how an *conformant* application handles the absence of a *property*.

### Required properties {#required-props}

A *property* which *must* be provided when a third party defining a new *term* in some particular *class* is called a **required property**.

{.example ...}
The notion of a *datatype* is defined in {§datatypes} of this standard, and is common to many FHISO standards. *Datatypes* are identified by a *term* known as their *datatype name*, and any party defining a *datatype* for use with FHISO standards is *required* to specify its *pattern*, *supertype* if any, and whether it is an *abstract datatype*. These pieces of information are specified via three *properties* called `types:pattern`, `types:nonTrivialSupertype` and `types:isAbstract`. These three *properties* are therefore the *required properties* for *datatypes*. In fact, *datatypes* have a fourth *required property* which is their *type*: i.e. a statement that the *term* is a *datatype*.
{/}

The status of a *property* being required for all *members* of a *class* is itself a *formal property* of that *class*.
The *property* for that *formal property* is `types:requiredProperty`
and has *range* `rdfs:Property`.

When a *class* has more than one *required property*, each is a separate *formal property* of the *class*.

The *required properties* of a *class* *shall* include all the *required properties* of each *superclass* of the *class*.

The `rdf:type` is a *required property* of `rdfs:Resource` and all *classes* are a *subclass* of `rdfs:Resource`, thus `rdf:type` is a *required property* of every *class*.

{.note} Saying that `ex:X` is a *required property* of *class* `ex:Y` means that each *member* of `ex:Y` must have a *property* with *property name* `ex:X`, not that `ex:Y` itself must have such a *property*.


## Data Values {#values}

### Datatypes {#datatypes}

A **datatype** is an *term* which is a formal description of how certain *strings* can be mapped directly to certain *entities* such that the identity and meaning of each *entity* can be inferred directly from that *datatype*'s treatment of the *string*.

The *term name* of a *datatype* is also called a **datatype name**.

A *datatype* has a **lexical space** which is the set of *strings* which are interpreted as valid values of the *datatype*. The definition of a *datatype* *shall* state how each *string* in its *lexical space* maps to an *entity*, and state the semantics associated with each of those *entities*.

A *datatype* has a **value space** which is the *entity class* of *entities* which can be represented by the *datatype*. The definition of a *datatype* *shall* state how each *member* of the *value space* maps to at least one *string*, and ensure that no two *entities* map to the same *string*.

{.note} This definition of a *datatype* is sufficiently aligned with XML Schema's notion of a simple type, as defined in \[[XSD Pt2](https://www.w3.org/TR/xmlschema11-2/)\], that XML Schema's simple types can be used as *datatypes* in this standard. Best practice on how to get an IRI for use as the *term name* of XML Schema types can be found in \[[SWBP XSD DT](https://www.w3.org/TR/swbp-xsch-datatypes/)\]. Similarly, this standard's definition of a *datatype* is very similar to the definition of a datatype in \[[RDF Concepts](https://www.w3.org/TR/rdf11-concepts/)\], and RDF datatypes can be used as *datatypes* in this standard.

{.example} XML Schema defines an integer type in §3.4.13 of \[[XSD Pt2](https://www.w3.org/TR/xmlschema11-2/)\] which is well-suited for use in this standard. FHISO uses this type where integer values occur. 

The mapping from lexical representations to *entities* need not be one-to-one. If a *datatype* has multiple lexical representations of the same *entity*, a *conformant* application *must* treat these representations equivalently and *may* change a *string* of that *datatype* to be a different but equivalent lexical representation.

{.note} This allows applications to store such *strings* internally using any representation of that *entity* (such as a database field or a variable) without retaining the original lexical representation.

{.example} The XML Schema `integer` *datatype* used in the previous example is one where the mapping from lexical representation to value is many-to-one rather than one-to-one. This is due to *lexical space* including strings with a leading `+` sign as well as superfluous leading `0`s, and means that "`00137`", "`+137`" and "`137`" all represent the same underlying *entity*: the number one hundred and thirty-seven. Because *conformant* applications *may* convert strings between equivalent lexical representations, they *may* store them in a database in an integer field and regenerate *strings* in a canonical representation.


A single *value space* may support more than one *datatype*.

{.example} The *value class* identifying all integers could be represented using the *datatype* `xsd:integer`, but could also be represented by other *datatypes* such as one representing integers in hexadecimal.

*Strings* outside the *lexical space* of a *datatype* *must not* be used where a *string* of that *datatype* is required. If an application encounters any such *strings*, it *may* remove them from the dataset or *may* convert them to a valid value in an implementation-defined manner. Any such conversion that is applied automatically by an application *must* either be locale-neutral or respect any locale given in the dataset.

{.ednote} The above "do what you want" rule for invalid lexemes may be more permissive than we actually want. But I don't think we want to deal with defining what it means to be non-conformant in this spec. Perhaps we should define something like "invalid token" that other specs can reference?

{.example} XML Schema defines a `date` type in §3.3.9 of \[[XSD Pt2](https://www.w3.org/TR/xmlschema11-2/)\] which has a *lexical space* based on \[ISO 8601\] dates. If, in a dataset that is somehow identified as being written in German, an application encountering the *string* "`8 Okt 2000`" in a context where an XML Schema `date` is expected, it *may* convert this to "`2000-10-08`". However an application encountering the *string* "`8/10/2000`" *must not* conclude this represents 8 October or 10 August unless the document includes a locale that uniquely determines the date format. In this case, information that the document is in English is not sufficient as different English-speaking countries have different conventions for formatting dates.

This standard uses the `rdfs:Datatype` *class* as the *class* of *datatypes*, defined as follows:

------              -----------------------------------------------------------
Name                `http://www.w3.org/2000/01/rdf-schema#Datatype`

Type                `http://www.w3.org/2000/01/rdf-schema#Class`

Superclass          `http://www.w3.org/2000/01/rdf-schema#Class`

Required properties `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`<br/>
                    `https://terms.fhiso.org/types/pattern`<br/>
                    `https://terms.fhiso.org/types/nonTrivialSupertypeCount`<br/>
                    `https://terms.fhiso.org/types/isAbstract`
------              -----------------------------------------------------------

: Class definition

The `rdfs:Datatype` *term* is defined in §2.4 of \[RDF Schema\].

{.note} The *class* of *datatypes*, `rdfs:Datatype`, is defined here to be a *subclass* of the *class* of all *classes*, `rdfs:Class`. This may appear counter-intuitive as new *classes* are normally defined to be a *subclass* only of `rdfs:Resource`, the *universal superclass*. The reason for doing this is partly for compatibility with its definition in \[RDF Schema\], but the reasons \[RDF Schema\] took this unusual decision are also valid here.

{.note} Making `rdfs:Datatype` a *subclass* of `rdfs:Class` says that a *datatype name* *may* be used where a *class name* is expected. In many situations this is desirable. For example, the *range* of a *property* is, in general, a *class name*, but frequently a *datatype name* will be used: for example, the *range* of `types:isAbstract` is the `xsd:boolean` *datatype*. By making `rdfs:Datatype` a *subclass* of `rdfs:Class`, the *range* of `rdfs:range` can be `rdfs:Class`.

One *datatype* can be a **subtype** of another *datatype*. The latter *datatype* is called the **supertype** of the former. The *value space* of the *subtype* *shall* be a *subclass* of the *value space* of the *supertype*. Each *string* in the *lexical space* of the *subtype* *shall* also be in the *lexical space* of the *supertype*, and *shall* map to the same *entity* in both *datatypes*.

{.example} Consider the *datatype* `xsd:anyURI`, which can represent any *entity* as a *term*, and the *datatype* `xsd:integer`, which represents integers using ASCII digits. The *entity class* of integers is a *subclass* of the *entity class* of all *entities*, and the *lexical space* of `xsd:integer` is a subset of the *lexical space* of `xsd:anyURI` (in particular, every integer is a valid relative IRI). However, `xsd:integer` is not a *subtype* of `xsd:anyURI` because the two are not guaranteed to map each *string* in the *lexical space* of `xsd:integer` to the same *entity*.



### Patterns

A party defining a *datatype* *shall* specify a **pattern** for that *datatype*. This is a regular expression which provides a constraint on the *lexical space* of the *datatype*. Matching the *pattern* might not be sufficient to validate a *string* as being in the *lexical space* of the *datatype*, but parties defining a *datatype* *must* ensure that all *strings* in the *lexical space* match the *pattern*, even if some *strings* outside the *lexical space* also match the *pattern*.

{.note} Patterns are included in this standard to provide a way for an application to find out about the *lexical space* of a unfamiliar *datatype* through *discovery*.

{.example ...}
The XML Schema `date` type mentioned in a previous example has the following *pattern* (here split onto two lines for readability --- the second line is an optional timezone which the XML Schema `date` type allows).

    -?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])
    (Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))? 

This *pattern* matches *strings* like "`1999-02-31`". Despite matching the *pattern*, this *string* is not part of the *lexical space* of this `date` type as 31 February is not a valid date.
{/}

The *property term* representing the *pattern* of a *datatype* is defined as follows:

  ------- -------------------------------------------------------
  Name    `https://terms.fhiso.org/types/pattern`
  Type    `http://www.w3.org/1999/02/22-rdf-syntax-ns#Property`
  Range   `https://terms.fhiso.org/types/Pattern`
  ------- -------------------------------------------------------

  : Property definition

{.note} The `types:Pattern` *datatype* used as the *range* of this property is defined in a separate \[FHISO Patterns\] standard which defines the dialect of regular expressions which FHISO supports.

{.ednote} We added \[FHISO Patterns\] after adding most of the *pattern* examples in this and other current draft standards, and have not yet reviewed them to ensure they all match that regular expression syntax.

{.ednote} This standard does not use `xsd:pattern` as the *property term*, even though it is used as a predicate in [OWL 2](https://www.w3.org/TR/owl2-syntax/). Its use would pose a difficulty because none of the relevant W3C specifications indicate what the `rdfs:domain` of `xsd:pattern` is supposed to be. Possibly it is an `owl:Restriction`, which would be incompatible with this use. Using `xsd:pattern` would also require us to use precisely the form of regular expression defined in Appendix G of \[XSD Pt2\].

A *datatype* with a *pattern* other than "`.*`" is known as a **structured datatype**, while one with a *pattern* of "`.*`" is known as an **unstructured datatype**.



### Literal Values

A **literal** is a *tagged string* consisting of 

- a *string*;
- a **datatype tag**, which is a *datatype* and identifies how the *string* can be converted into an *entity* in the *value class* of the *datatype*; and
- a *language tag* as defined in [Basic Concepts].

The *datatype tag* and *language tag* may be defined either explicitly or implicitly; if unspecified, the defaults of `rdf:langString` and `und`, respectively, *must* be used.

A **literal value** is a non-empty set of *literals* all representing the same *entity*. *Literal values* with more than one element are used to provide alternative representations that users might be expected to value but software might not be able to recreate from other *literals* in the set.

{.example ...} Consider the following *literal value* consisting of three *literals*:

string          datatype            language
-------------   ------------------  -------------------
`Luther`        `rdf:langString`    `en`
`Ruteru`        `rdf:langString`    `ja-Latn`
`ルテル`           `rdf:langString`    `ja`

All three *literals* *should* be preserved if the software cannot recreate them from one another, though software with name translation software may be able to discard some of them.
{/}

{.example ...} Consider the following *literal value* consisting of three *literals*:

string              datatype            language
-------------       ------------------  -------------------
`1000000`           `xsd:integer`       `und`
`1e6`               `xsd:double`        `und`
`one million`       `rdf:langString`    `en`

Only one of the first two *literals* *should* be included because the two are readily derived from one another. The last *literal* *should not* be included unless both (a) writing the number as "`one million`" is important in context and (b) the application is unable to re-create this representation automatically.
{/}

{.example ...}  FHISO intends to standardise a *datatype* identified by the *term* `types:CreatorsName`

This *datatype* will include both internal formatting to support various name orders and sorting rules, and also include language tags to represent the human languages in which names are presented.
An example *literal value* thus might be

|string                        |datatype            |language|
|------------------------------|--------------------|--------|
|`Tychonievich, Luther`        |`types:CreatorsName`| `en`   |
|`タイコノヸズ ルテル | タイコノヸズ`|`types:CreatorsName`| `ja`   |
{/}

Because the *datatype* `xsd:anyURI` has as its *value space* `rds:Resource`, an `xsd:anyURI` *literal* can be used in any *literal value* provided it's identified *entity* is a member of the *literal value*'s *value space*. 

{.note} An *entity* represented with *datatype* `xsd:anyURI` is equivalent to a *term*, as defined in [Basic Concepts].
Including a *term* in a *literal value* allows *properties* to be defined with that *literal value*'s underlying *entity* as its *subject*.

{.example ...}
Suppose a data model defines a *property* `http://example.com/birth-date`
describing the date of the birth of its *subject* person,
with *range* being a date.

...
{/}

